<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Snippet Tree Explorer</title>
    <style>
        :root {
            --sne-indent: 14px;
            --sne-icon-space: 18px;
        }

        body {
            font-family: var(--vscode-font-family, sans-serif);
            font-size: var(--vscode-font-size, 13px);
            padding: 4px;
            margin: 0;
            background-color: var(--vscode-sideBar-background);
            color: var(--vscode-sideBar-foreground);
        }

        ul {
            list-style: none;
            padding-left: 0;
            margin: 0;
        }

        .sne-folder,
        .sne-file {
            display: flex;
            align-items: center;
            height: 22px;
            padding-left: var(--sne-indent);
            cursor: default;
        }

        .sne-folder:hover,
        .sne-file:hover {
            background-color: var(--vscode-list-hoverBackground);
        }

        .sne-folder.drag-over {
            background-color: var(--vscode-list-dropBackground, #005f5f30);
        }

        .sne-selected {
            background-color: var(--vscode-list-activeSelectionBackground) !important;
            color: var(--vscode-list-activeSelectionForeground);
        }

        .sne-icon {
            display: inline-block;
            width: var(--sne-icon-space);
            text-align: center;
            margin-right: 4px;
            color: var(--vscode-icon-foreground);
        }

        .sne-editable {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border: 1px solid transparent;
            padding: 0 2px;
        }

        .sne-editable:focus {
            outline: none;
            border-color: var(--vscode-focusBorder);
            background: var(--vscode-input-background);
            color: var(--vscode-input-foreground);
        }

        .sne-collapsed>ul {
            display: none;
        }

        ul ul {
            padding-left: var(--sne-indent);
        }

        .sne-context {
            position: fixed;
            background: var(--vscode-editor-background);
            color: var(--vscode-editor-foreground);
            border: 1px solid var(--vscode-editorWidget-border);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }

        .sne-context div {
            padding: 4px 12px;
            cursor: pointer;
        }

        .sne-context div:hover {
            background-color: var(--vscode-list-hoverBackground);
        }

        .sne-collapsed>.sne-folder .sne-icon {
            transform: rotate(-90deg);
            transition: transform 0.15s ease;
        }

        .sne-folder .sne-icon {
            transition: transform 0.15s ease;
        }

        .menu-item-disabled {
            opacity: 0.4;
            pointer-events: none;
            cursor: default;
        }

        .sne-context hr {
            border: none;
            border-top: 1px solid var(--vscode-editorWidget-border);
            margin: 4px 0;
        }
    </style>
</head>

<body>
    <ul id="sne-tree"></ul>
    <div id="sne-error-dialog"></div>
    <div id="sne-context-menu" class="sne-context" style="display: none;"></div>

    <script>
        const vscode = acquireVsCodeApi();

        class NodeItem {
            constructor(tree, node, parentUl, isTopLevel) {
                // tree ref
                this.tree = tree;

                // node
                this.name = node.name;
                this.fullPath = node.fullPath;
                this.isFolder = node.isFolder;

                // work-around for top tree folders
                this.isTopLevel = isTopLevel;

                // node in a parent's scope
                this.init(parentUl)
            }

            init(parentUl) {
                const li = document.createElement('li');
                if (this.isFolder) {
                    li.classList.add('sne-collapsed');
                }

                const wrapper = document.createElement('div');
                wrapper.className = this.isFolder ? 'sne-folder' : 'sne-file';
                wrapper.draggable = !this.isTopLevel;

                const icon = document.createElement('span');
                icon.className = 'sne-icon';
                icon.innerHTML =
                    this.isFolder ?
                        '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#5f6368"><path d="M480-344 240-584l56-56 184 184 184-184 56 56-240 240Z"/></svg>'
                        : '<svg xmlns="http://www.w3.org/2000/svg" height="16px" viewBox="0 -960 960 960" width="16px" fill="#5f6368"><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-120H640q-30 38-71.5 59T480-240q-47 0-88.5-21T320-320H200v120Zm280-120q38 0 69-22t43-58h168v-360H200v360h168q12 36 43 58t69 22ZM200-200h560-560Zm80-270h400v-80H280v80Zm0-140h400v-80H280v80Z"/></svg>';

                const span = document.createElement('span');
                span.className = 'sne-editable';
                span.textContent = this.name;
                span.contentEditable = false;

                this.initSingleClickHandlers(li, wrapper, span);
                this.initItemRename(wrapper, span);
                this.initDragAndDrop(wrapper, span);

                wrapper.appendChild(icon);
                wrapper.appendChild(span);
                li.appendChild(wrapper);
                parentUl.appendChild(li);

                this.wrapper = wrapper;
                this.li = li;
                this.tree.nodeMap.set(this.fullPath, this);
            }

            initDragAndDrop(wrapper, span) {
                wrapper.ondragstart = (e) => {
                    if (this.isFolder && this.isTopLevel) {
                        e.preventDefault();
                        return;
                    }
                    e.dataTransfer.setData('text/plain', (this.isFolder ? "folder:" : "file:") + this.fullPath);
                };

                wrapper.ondragover = (e) => {
                    if (this.isFolder) {
                        e.preventDefault();
                        wrapper.style.backgroundColor = 'var(--vscode-list-hoverBackground)';
                    }
                };

                wrapper.ondragleave = () => {
                    if (this.isFolder) {
                        wrapper.style.backgroundColor = '';
                    }
                };

                wrapper.ondrop = (e) => {
                    e.preventDefault();
                    wrapper.style.backgroundColor = '';

                    const dragData = e.dataTransfer.getData('text/plain').split(":");

                    const sourcePath = dragData[1];
                    const isMovingFolder = dragData[0] === "folder";

                    const targetPath = this.isFolder ? this.fullPath : this.fullPath.substring(0, this.fullPath.lastIndexOf('/'));

                    if (this.isFolder && targetPath.startsWith(sourcePath)) {
                        this.tree.showErrorDialog('Cannot move a parent folder into its own subfolder.');
                        return;
                    }

                    if (!isMovingFolder) {
                        const baseSource = sourcePath.substring(0, sourcePath.lastIndexOf('/'));
                        if (baseSource === targetPath) {
                            return;
                        }
                    }

                    if (sourcePath && targetPath && sourcePath !== targetPath) {
                        this.tree.postCommand('move', { sourcePath, targetPath, isFolder: isMovingFolder })
                            .then(() => {
                                this.tree.moveTreeNodeUI(sourcePath, targetPath);
                            })
                            .catch(err => {
                                this.tree.showErrorDialog(err);
                            });
                    }
                };
            }

            initItemRename(wrapper, span) {
                span.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        span.blur();
                    }

                    if (e.key === 'Esc' && span.contentEditable) {
                        e.preventDefault();
                        span.contentEditable = false;
                        span.textContent = "eeeee:" +this.name;
                    }
                };

                span.onblur = () => {
                    if (!span.contentEditable)
                        return;

                    let newName = span.textContent.trim();
                    span.contentEditable = false;

                    if (!this.isFolder && !newName.endsWith('.snippet')) {
                            newName = newName + '.snippet';
                    }

                    if (newName !== this.name) {    

                        const parentPath = this.fullPath.substring(0, this.fullPath.lastIndexOf('/'));
                        const error = this.tree._validateRename(parentPath, newName);

                        if (error) {
                            this.tree.showErrorDialog(error);
                            span.textContent = this.name;
                            return;
                        }

                        this.tree.postCommand('rename', {
                            oldPath: this.fullPath,
                            newName
                        }).then((data) => {
                            const oldPath = this.fullPath;
                            this.name = newName;
                            this.fullPath = parentPath + '/' + newName;
                            span.textContent = newName;

                            const nodeItem = this.tree.nodeMap.get(oldPath);
                            this.tree.nodeMap.set(this.fullPath, nodeItem);
                            this.tree.nodeMap.delete(oldPath);

                            if (this.isFolder) {
                                this.tree._updateSubtreePaths(oldPath, this.fullPath);
                            }
                        })
                            .catch(err => {
                                this.tree.showErrorDialog(err);
                                span.textContent = this.name;
                            });
                    }
                };
            }

            initSingleClickHandlers(li, wrapper, span) {
                wrapper.oncontextmenu = (e) => {
                    e.preventDefault();
                    this.tree.selectItem(this);
                    const x = e.clientX;
                    const y = e.clientY;
                    this.tree.showContextMenu(x, y, this, li);
                };

                wrapper.onclick = (e) => {
                    this.tree.selectItem(this);

                    if (this.isFolder) {
                        e.stopPropagation();
                        if (li.classList.contains('sne-collapsed')) {
                            li.classList.remove('sne-collapsed');
                            this.tree.addExpandedPath(this.fullPath);
                            if (!li.querySelector('ul')) {
                                const ul = document.createElement('ul');
                                li.appendChild(ul);
                                this.tree.postCommand('expand', { path: this.fullPath })
                                    .then((data) => {
                                        this.tree.renderTree(data, this.fullPath);
                                    })
                                    .catch(err => {
                                        this.tree.showErrorDialog(err);
                                    });
                            }
                        } else {
                            li.classList.add('sne-collapsed');
                            this.tree.removeExpandedPath(this.fullPath);
                        }
                    }
                };

                span.ondblclick = () => {
                    this.tree.selectItem(this);

                    if (!this.isFolder) {
                        vscode.postMessage({ type: 'openFile', path: this.fullPath });
                    } else {
                        span.focus();
                    }
                };
            }

            toggleSelect(enable) {
                if (enable) {
                    this.wrapper.classList.add('sne-selected');
                } else {
                    this.wrapper.classList.remove('sne-selected');
                }
            }

            toggleExpand(expanded) {
                if (expanded) {
                    this.li.classList.remove('sne-collapsed');
                } else {
                    this.li.classList.add('sne-collapsed');
                }
            }

            getUl() {
                return this.li.querySelector('ul');
            }

            getOrCreateUl() {
                let ul = this.getUl();
                if (!ul) {
                    ul = document.createElement('ul');
                    this.li.appendChild(ul);
                }
                return ul;
            }

            destroy() {
                this.li.remove();
            }
        }

        class SnippetTreeView {
            constructor(containerId) {
                this.root = document.getElementById(containerId);
                this.contextMenu = document.getElementById('sne-context-menu');
                this.nodeMap = new Map();
                this.selectedNode = null;
                this.expandedPaths = new Set();

                document.addEventListener('click', () => {
                    this.hideContextMenu();
                });

                this.callbackMap = new Map();
                this.callbackCounter = 1;
                this.contextAction = '';
                this.contextActionTime = 0;

                this.init();
            }

            init() {
                window.addEventListener('scroll', () => {
                    this.hideContextMenu();
                }, true);

                window.addEventListener('click', () => {
                    this.hideContextMenu();
                }, true);
            }

            postCommand(command, data = {}) {
                return new Promise((resolve, reject) => {
                    const callbackId = `cb_${Date.now()}_${this.callbackCounter++}`;
                    this.callbackMap.set(callbackId, { resolve, reject });

                    vscode.postMessage({
                        type: command,
                        ...data,
                        callbackId
                    });
                });
            }

            _validateRename(parentPath, newName) {
                if (!newName || newName.trim() === '') {
                    return 'Name cannot be empty';
                }

                if (newName.includes('/')) {
                    return "Name cannot contain '/'";
                }

                if (newName.includes('..')) {
                    return "Name cannot contain '..'";
                }

                const newFullPath = parentPath + '/' + newName;
                if (this.nodeMap.has(newFullPath)) {
                    return 'An item with this name already exists';
                }
                return null;
            }

            _updateSubtreePaths(oldBase, newBase) {
                for (const [path, nodeItem] of this.nodeMap.entries()) {
                    if (path.startsWith(oldBase + '/')) {
                        const newPath = newBase + path.substring(oldBase.length);
                        nodeItem.fullPath = newPath;
                        this.nodeMap.set(newPath, nodeItem);
                        this.nodeMap.delete(path);
                    }
                }

                const pathsToUpdate = Array.from(this.expandedPaths).filter(p => p.startsWith(oldBase + '/'));
                pathsToUpdate.forEach(oldPath => {
                    this.expandedPaths.delete(oldPath);
                    const newPath = newBase + oldPath.substring(oldBase.length);
                    this.expandedPaths.add(newPath);
                });
            }

            addExpandedPath(path) {
                this.expandedPaths.add(path);
                this.saveTreeState();
            }

            removeExpandedPath(path) {
                this.expandedPaths.delete(path);
                this.saveTreeState();
            }

            saveTreeState() {
                vscode.postMessage({
                    type: 'saveTreeState',
                    expandedPaths: Array.from(this.expandedPaths)
                });
            }

            restoreTreeState(expandedPaths) {
                if (!expandedPaths || expandedPaths.length === 0) {
                    return;
                }

                this.expandedPaths = new Set(expandedPaths);
                const pathsToRestore = expandedPaths.filter(folderPath => {
                    const nodeItem = this.nodeMap.get(folderPath);
                    return nodeItem && nodeItem.isFolder;
                });

                pathsToRestore.forEach(folderPath => {
                    const nodeItem = this.nodeMap.get(folderPath);
                    if (nodeItem && nodeItem.isFolder) {
                        const li = nodeItem.li;
                        if (li.classList.contains('sne-collapsed')) {
                            li.classList.remove('sne-collapsed');
                            if (!li.querySelector('ul')) {
                                const ul = document.createElement('ul');
                                li.appendChild(ul);
                                this.postCommand('expand', { path: folderPath })
                                    .then((data) => {
                                        this.renderTree(data, folderPath);
                                    })
                                    .catch(err => {
                                        this.showErrorDialog(err);
                                    });
                            }
                        }
                    }
                });
            }

            addFolder() {
                this._expandAndAddNode(true);
            }

            addSnippet() {
                this._expandAndAddNode(false);
            }

            _expandAndAddNode(isFolder) {
                const selected = this.selectedNode;
                if (!selected) {
                    this.showErrorDialog("Please select a folder first.");
                    return;
                }

                const selectedPath = selected.fullPath;
                const parentPath = selected.isFolder ? selectedPath : selectedPath.substring(0, selectedPath.lastIndexOf('/'));

                const parentLiEl = this.nodeMap.get(parentPath);
                if (!parentLiEl) {
                    this.showErrorDialog("Parent folder not found. Please select a folder first.");
                    return;
                }

                const subtreeLoaded = parentLiEl.getUl();

                if (!subtreeLoaded) {
                    const wrapper = parentLiEl.wrapper;
                    if (wrapper && parentLiEl.li.classList.contains('sne-collapsed')) {
                        wrapper.dispatchEvent(new MouseEvent('click', { bubbles: true }));
                    }
                    setTimeout(() => this._addEmptyEditableNode(parentPath, isFolder), 200);
                    return;
                }

                if (parentLiEl.li.classList.contains('sne-collapsed')) {
                    parentLiEl.li.classList.remove('sne-collapsed');
                    this.addExpandedPath(parentPath);
                }

                setTimeout(() => this._addEmptyEditableNode(parentPath, isFolder), 100);

            }


            _addEmptyEditableNode(parentPath, isFolder) {
                const parentNode = this.nodeMap.get(parentPath);
                if (!parentNode) {
                    this.showErrorDialog("Parent folder not found. Please try again.");
                    return;
                }

                const ul = parentNode.getOrCreateUl();

                if (ul.querySelector('.sne-editing')) {
                    ul.querySelector('.sne-editing').remove();
                }

                const tempFullPath = parentPath + '/';
                const node = {
                    name: '',
                    fullPath: tempFullPath,
                    isFolder: isFolder
                };

                const li = document.createElement('li');
                const wrapper = document.createElement('div');
                wrapper.className = (isFolder ? 'sne-folder' : 'sne-file') + ' sne-editing';

                const icon = document.createElement('span');
                icon.className = 'sne-icon';
                icon.innerHTML = isFolder ? '> ' : '= ';

                const span = document.createElement('span');
                span.className = 'sne-editable';
                span.contentEditable = true;
                span.textContent = '';
                span.dataset.fullPath = tempFullPath;
                span.dataset.isFolder = String(isFolder);

                const error = document.createElement('div');
                error.style.color = 'var(--vscode-errorForeground)';
                error.style.fontSize = '11px';
                error.style.padding = '0 2px';

                function cleanup() {
                    li.remove();
                }

                let self = this;
                function handleValidate() {
                    const newName = span.textContent.trim();

                    let errorName = self._validateRename(parentPath, newName);

                    if (errorName) {
                        error.textContent = errorName;
                        return false;
                    }

                    // clear error if new name is valid
                    error.textContent = '';
                    return true;
                }

                async function handleCreate() {
                    let newName = span.textContent.trim();
                    
                    
                    if (!handleValidate()) {
                        if (newName === '') cleanup();
                        return;
                    }

                    if (!span.contentEditable) {
                        return;
                    }

                    if (!isFolder && !newName.endsWith('.snippet')) {
                        newName = newName + '.snippet';
                        span.textContent = newName;
                    }
        
                    // update span text content to the new name
                    span.textContent = newName;
                    // disable content editable
                    span.contentEditable = false;

                    const newFullPath = parentPath + '/' + newName;

                    try {
                        await tree.postCommand(isFolder ? "createFolder" : "createSnippet", {
                            path: newFullPath
                        });

                        cleanup();
                        
                        const parentNode = tree.nodeMap.get(parentPath);
                        if (parentNode && parentNode.isFolder) {
                            parentNode.li.classList.remove('sne-collapsed');
                            tree.addExpandedPath(parentPath);
                        }
                        
                        tree.renderNode({
                            name: newName,
                            fullPath: newFullPath,
                            isFolder: isFolder
                        }, ul, false);

                    } catch (err) {
                        cleanup();
                        tree.showErrorDialog(err.message || "Failed to create item.");
                    }
                }

                span.oninput = () => {
                    handleValidate();
                };

                span.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        span.blur();
                    } else {
                        handleValidate();
                    }
                };

                span.onblur = () => {
                    handleCreate();
                };

                wrapper.appendChild(icon);
                wrapper.appendChild(span);
                li.appendChild(wrapper);
                li.appendChild(error);
                ul.appendChild(li);
                span.focus();
            }


            hideContextMenu() {
                this.contextMenu.style.display = 'none';
            }

            showContextMenu(x, y, node, li) {
                this.contextMenu.innerHTML = '';

                if (node.isTopLevel)
                    return;

                const addSeparator = () => {
                    const hr = document.createElement('hr');
                    hr.className = 'sne-separator';
                    this.contextMenu.appendChild(hr);
                };

                const addItem = (label, handler, disabled = false) => {
                    const div = document.createElement('div');
                    div.textContent = label;

                    if (disabled) {
                        div.classList.add('menu-item-disabled');
                    }

                    div.onclick = () => {
                        this.hideContextMenu();
                        handler(disabled);
                    };
                    this.contextMenu.appendChild(div);
                };

                if (!node.isFolder) {
                    addItem('Open', () => vscode.postMessage({ type: 'openFile', path: node.fullPath }));
                    addItem('Open as text', () => vscode.postMessage({ type: 'openText', path: node.fullPath }));
                    addSeparator();
                }

                addItem('Copy', () => {
                    this.contextAction = "copy:" + (node.isFolder? "folder:": "file:") + node.fullPath;
                    this.contextActionTime = Date.now();
                });
                addItem('Cut', () => {
                    this.contextActionTime = Date.now();
                    this.contextAction = "move:" + (node.isFolder? "folder:": "file:") + node.fullPath;
                });
                addItem('Paste', (disabled) => {
                    if (!disabled && this.contextAction != "") {
                        const tmp = this.contextAction.split(":");
                        if (tmp.length === 3) {
                            this.handlePasteCommand(
                                tmp[0], tmp[2], tmp[1] === "folder",
                                node.fullPath, node.isFolder);
                        }
                    }

                    this.contextAction = "";
                    this.contextActionTime = 0;
                }, (Date.now() - this.contextActionTime > 60000));

                addSeparator();

                addItem('Open Config', () => {
                    vscode.postMessage({ type: 'openConfig' });
                });

                addSeparator();

                addItem('Rename', () => {
                    const span = li.querySelector('.sne-editable');
                    span.contentEditable = true;
                    span.focus();
                });

                addItem('Delete', () => {
                    this.postCommand('remove', { fullPath: node.fullPath, name: node.name, isFolder: node.isFolder })
                        .then((data) => {
                            if (data.path && data.path != '') {
                                if (node.isFolder) {
                                    this.removeExpandedPath(node.fullPath);
                                    for (const [path, nodeItem] of this.nodeMap.entries()) {
                                        if (path.startsWith(node.fullPath + '/')) {
                                            this.nodeMap.delete(path);
                                            this.removeExpandedPath(path);
                                        }
                                    }
                                }
                                node.destroy();
                                this.nodeMap.delete(node.fullPath);
                            }
                        })
                        .catch(err => {
                            if (err && err != '') {
                                this.showErrorDialog(err);
                            }
                        });
                });

                this.contextMenu.style.left = `${x}px`;
                this.contextMenu.style.top = `${y}px`;
                this.contextMenu.style.display = 'block';
            }

            handlePasteCommand(command, sourcePath, isMovingFolder, dstPath, isDstFolder) {
                const targetPath = isDstFolder ? dstPath : dstPath.substring(0, dstPath.lastIndexOf('/'));

                if (isMovingFolder && targetPath.startsWith(sourcePath)) {
                    this.showErrorDialog(`Cannot ${command} a parent folder into its own subfolder.`);
                    return;
                }

                if (!isMovingFolder) {
                    const baseSource = sourcePath.substring(0, sourcePath.lastIndexOf('/'));
                    if (baseSource === targetPath) {
                        return;
                    }
                }

                if (sourcePath && targetPath && sourcePath !== targetPath) {
                    this.postCommand(command, { sourcePath, targetPath, isFolder: isMovingFolder })
                        .then(() => {
                            if (command === 'move') {
                                this.moveTreeNodeUI(sourcePath, targetPath);
                            }
                            else if (command === "copy") {
                                const tmp = sourcePath.split("/");
                                const name = tmp[tmp.length - 1];
                                const targetNode = this.nodeMap.get(targetPath);

                                if (targetNode && targetNode.getUl()) {
                                    this.renderNode({
                                        name,
                                        fullPath: targetPath + "/" + name,
                                        isFolder: isMovingFolder,
                                    },
                                    targetNode.getUl());
                                }
                            }
                        })
                        .catch(err => {
                            this.showErrorDialog(err);
                        });
                }
            }

            showErrorDialog(errorMessage) {
                const existing = document.getElementById('sne-error-dialog');
                if (existing) existing.remove();

                const dialog = document.createElement('div');
                dialog.id = 'sne-error-dialog';
                dialog.style.position = 'fixed';
                dialog.style.top = '50%';
                dialog.style.left = '50%';
                dialog.style.transform = 'translate(-50%, -50%)';
                dialog.style.background = 'var(--vscode-editorWidget-background)';
                dialog.style.color = 'var(--vscode-editorWidget-foreground)';
                dialog.style.border = '1px solid var(--vscode-editorWidget-border)';
                dialog.style.padding = '16px';
                dialog.style.zIndex = '10000';
                dialog.style.minWidth = '280px';
                dialog.style.boxShadow = '0 4px 10px rgba(0, 0, 0, 0.4)';
                dialog.style.borderRadius = '6px';

                const message = document.createElement('div');
                message.textContent = errorMessage;
                message.style.marginBottom = '12px';
                dialog.appendChild(message);

                const button = document.createElement('button');
                button.textContent = 'OK';
                button.style.padding = '4px 12px';
                button.style.background = 'var(--vscode-button-background)';
                button.style.color = 'var(--vscode-button-foreground)';
                button.style.border = 'none';
                button.style.borderRadius = '4px';
                button.style.cursor = 'pointer';

                button.onmouseover = () => {
                    button.style.background = 'var(--vscode-button-hoverBackground)';
                };

                button.onmouseout = () => {
                    button.style.background = 'var(--vscode-button-background)';
                };

                button.onclick = () => {
                    dialog.remove();
                };

                dialog.appendChild(button);
                document.body.appendChild(dialog);
            }

            selectItem(nodeItem) {
                if (this.selectedNode) {
                    this.selectedNode.toggleSelect(false);
                }
                nodeItem.toggleSelect(true);
                this.selectedNode = nodeItem;
            }

            moveTreeNodeUI(sourcePath, targetPath) {
                const sourceNode = this.nodeMap.get(sourcePath);
                if (!sourceNode) {
                    return;
                }

                const baseName = sourceNode.name;
                const isFolder = sourceNode.isFolder;

                sourceNode.destroy();
                this.nodeMap.delete(sourcePath);

                const newNode = {
                    name: baseName,
                    fullPath: `${targetPath}/${baseName}`,
                    isFolder: isFolder
                };

                const targetNode = this.nodeMap.get(targetPath);
                const ul = targetNode.getUl();

                if (ul) {
                    targetNode.toggleExpand(true);
                    this.renderNode(newNode, ul, false);
                } else {
                    targetNode.wrapper.dispatchEvent(new MouseEvent('click', { bubbles: true }));
                }
            }

            renderNode(node, parentUl, isTopLevel = false) {
                const item = new NodeItem(this, node, parentUl, isTopLevel);
                this.nodeMap.set(node.fullPath, item);
            }

            renderTree(data, parentPath = null) {
                const parentNode = parentPath ? this.nodeMap.get(parentPath) : null;
                const ul = parentNode?.getOrCreateUl() || this.root;
                data.forEach(node => this.renderNode(node, ul, parentPath === null));
            }

            reset() {
                this.root.innerHTML = '';
                this.nodeMap.clear();
            }
        }

        const tree = new SnippetTreeView('sne-tree');

        window.addEventListener('message', event => {
            const message = event.data;

            if (message.type === 'onCallback') {
                const callback = tree.callbackMap.get(message.callbackId);
                if (callback) {
                    tree.callbackMap.delete(message.callbackId);
                    if (message.success) {
                        callback.resolve(message.data);
                    } else {
                        callback.reject(new Error(message.error || 'Unknown error'));
                    }
                }
            }

            if (message.type === "addFolder") {
                tree.addFolder();
            }

            if (message.type === "addSnippet") {
                tree.addSnippet();
            }

            if (message.type === "refresh") {
                tree.reset();
                tree.renderTree(message.data.children);
                if (message.data.treeState && message.data.treeState.length > 0) {
                    setTimeout(() => {
                        tree.restoreTreeState(message.data.treeState);
                    }, 100);
                }
            }
        });

        tree.postCommand('ready', {})
            .then((data) => {
                tree.reset();
                tree.renderTree(data.children || data);
                if (data.treeState && data.treeState.length > 0) {
                    setTimeout(() => {
                        tree.restoreTreeState(data.treeState);
                    }, 100);
                }
            })
            .catch(err => {
                tree.showErrorDialog(err);
            });


    </script>
</body>

</html>