<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Snippet Tree Explorer</title>
    <style>
        :root {
            --sne-indent: 14px;
            --sne-icon-space: 18px;
        }

        body {
            font-family: var(--vscode-font-family, sans-serif);
            font-size: var(--vscode-font-size, 13px);
            padding: 4px;
            margin: 0;
            background-color: var(--vscode-sideBar-background);
            color: var(--vscode-sideBar-foreground);
        }

        ul {
            list-style: none;
            padding-left: 0;
            margin: 0;
        }

        .sne-folder,
        .sne-file {
            display: flex;
            align-items: center;
            height: 22px;
            padding-left: var(--sne-indent);
            cursor: default;
        }

        .sne-folder:hover,
        .sne-file:hover {
            background-color: var(--vscode-list-hoverBackground);
        }

        .sne-folder.drag-over {
            background-color: var(--vscode-list-dropBackground, #005f5f30);
        }

        .sne-selected {
            background-color: var(--vscode-list-activeSelectionBackground) !important;
            color: var(--vscode-list-activeSelectionForeground);
        }

        .sne-icon {
            display: inline-block;
            width: var(--sne-icon-space);
            text-align: center;
            margin-right: 4px;
            color: var(--vscode-icon-foreground);
        }

        .sne-editable {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border: 1px solid transparent;
            padding: 0 2px;
        }

        .sne-editable:focus {
            outline: none;
            border-color: var(--vscode-focusBorder);
            background: var(--vscode-input-background);
            color: var(--vscode-input-foreground);
        }

        .sne-collapsed>ul {
            display: none;
        }

        ul ul {
            padding-left: var(--sne-indent);
        }

        .sne-context {
            position: fixed;
            background: var(--vscode-editor-background);
            color: var(--vscode-editor-foreground);
            border: 1px solid var(--vscode-editorWidget-border);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }

        .sne-context div {
            padding: 4px 12px;
            cursor: pointer;
        }

        .sne-context div:hover {
            background-color: var(--vscode-list-hoverBackground);
        }

        .sne-collapsed>.sne-folder .sne-icon {
            transform: rotate(-90deg);
            transition: transform 0.15s ease;
        }

        .sne-folder .sne-icon {
            transition: transform 0.15s ease;
        }

        .menu-item-disabled {
            opacity: 0.4;
            pointer-events: none;
            cursor: default;
        }

        .sne-context hr {
            border: none;
            border-top: 1px solid var(--vscode-editorWidget-border);
            margin: 4px 0;
        }

        /* Dialog styles */
        .sne-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--vscode-editorWidget-background);
            color: var(--vscode-editorWidget-foreground);
            border: 1px solid var(--vscode-editorWidget-border);
            padding: 16px;
            z-index: 10000;
            min-width: 280px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
            border-radius: 6px;
        }

        .sne-dialog-message {
            margin-bottom: 12px;
        }

        .sne-dialog-message-large {
            margin-bottom: 16px;
        }

        .sne-dialog-button {
            padding: 4px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .sne-dialog-button-primary {
            background: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
        }

        .sne-dialog-button-primary:hover {
            background: var(--vscode-button-hoverBackground);
        }

        .sne-dialog-button-secondary {
            background: var(--vscode-button-secondaryBackground);
            color: var(--vscode-button-secondaryForeground);
            margin-right: 8px;
        }

        .sne-dialog-button-secondary:hover {
            background: var(--vscode-button-secondaryHoverBackground);
        }

        .sne-dialog-button-container {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }
    </style>
</head>

<body>
    <ul id="sne-tree"></ul>
    <div id="sne-error-dialog"></div>
    <div id="sne-context-menu" class="sne-context" style="display: none;"></div>

    <script>
        // ============================================================================
        // MessageManager - Centralizes all vscode.postMessage and message listening
        // ============================================================================
        class MessageManager {
            constructor() {
                this.vscode = acquireVsCodeApi();
                this.callbackMap = new Map();
                this.callbackCounter = 1;
                this.messageHandlers = new Map();
            }

            // Send a command and wait for callback
            sendCommand(type, data = {}) {
                return new Promise((resolve, reject) => {
                    const callbackId = `cb_${Date.now()}_${this.callbackCounter++}`;
                    this.callbackMap.set(callbackId, { resolve, reject });

                    this.vscode.postMessage({
                        type: type,
                        ...data,
                        callbackId
                    });
                });
            }

            // Send a message without waiting for response
            sendMessage(type, data = {}) {
                this.vscode.postMessage({ type, ...data });
            }

            // Register handler for incoming messages
            onMessage(type, handler) {
                if (!this.messageHandlers.has(type)) {
                    this.messageHandlers.set(type, []);
                }
                this.messageHandlers.get(type).push(handler);
            }

            // Initialize message listener (called once)
            initialize() {
                window.addEventListener('message', event => {
                    const message = event.data;

                    // Handle callbacks
                    if (message.type === 'onCallback') {
                        const callback = this.callbackMap.get(message.callbackId);
                        if (callback) {
                            this.callbackMap.delete(message.callbackId);
                            if (message.success) {
                                callback.resolve(message.data);
                            } else {
                                callback.reject(new Error(message.error || 'Unknown error'));
                            }
                        }
                        return;
                    }

                    // Handle other message types
                    const handlers = this.messageHandlers.get(message.type);
                    if (handlers) {
                        handlers.forEach(handler => handler(message));
                    }
                });
            }
        }

        // ============================================================================
        // DialogManager - Handles all dialog showing (error, confirm, etc.)
        // ============================================================================
        class DialogManager {
            showErrorDialog(errorMessage) {
                const existing = document.getElementById('sne-error-dialog');
                if (existing) existing.remove();

                const dialog = document.createElement('div');
                dialog.id = 'sne-error-dialog';
                dialog.className = 'sne-dialog';

                const message = document.createElement('div');
                message.className = 'sne-dialog-message';
                message.textContent = errorMessage;
                dialog.appendChild(message);

                const button = document.createElement('button');
                button.className = 'sne-dialog-button sne-dialog-button-primary';
                button.textContent = 'OK';
                button.onclick = () => {
                    dialog.remove();
                };

                dialog.appendChild(button);
                document.body.appendChild(dialog);
            }

            showConfirmDialog(message, onConfirm, onCancel) {
                const existing = document.getElementById('sne-confirm-dialog');
                if (existing) existing.remove();

                const dialog = document.createElement('div');
                dialog.id = 'sne-confirm-dialog';
                dialog.className = 'sne-dialog';

                const messageDiv = document.createElement('div');
                messageDiv.className = 'sne-dialog-message-large';
                messageDiv.textContent = message;
                dialog.appendChild(messageDiv);

                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'sne-dialog-button-container';

                const cancelButton = document.createElement('button');
                cancelButton.className = 'sne-dialog-button sne-dialog-button-secondary';
                cancelButton.textContent = 'Cancel';
                cancelButton.onclick = () => {
                    dialog.remove();
                    if (onCancel) onCancel();
                };

                const confirmButton = document.createElement('button');
                confirmButton.className = 'sne-dialog-button sne-dialog-button-primary';
                confirmButton.textContent = 'Confirm';
                confirmButton.onclick = () => {
                    dialog.remove();
                    if (onConfirm) onConfirm();
                };

                buttonContainer.appendChild(cancelButton);
                buttonContainer.appendChild(confirmButton);
                dialog.appendChild(buttonContainer);
                document.body.appendChild(dialog);
            }
        }

        // ============================================================================
        // TreeCommandHandler - Handles all tree-related commands
        // ============================================================================
        class TreeCommandHandler {
            constructor(messageManager, treeView) {
                this.messageManager = messageManager;
                this.treeView = treeView;
                this.dialogManager = new DialogManager();
            }

            async expand(path) {
                return await this.messageManager.sendCommand('expand', { path });
            }

            async rename(oldPath, newName) {
                return await this.messageManager.sendCommand('rename', {
                    oldPath,
                    newName
                });
            }

            async createFolder(path) {
                return await this.messageManager.sendCommand('createFolder', { path });
            }

            async createSnippet(path) {
                return await this.messageManager.sendCommand('createSnippet', { path });
            }

            async remove(fullPath, name, isFolder) {
                return await this.messageManager.sendCommand('remove', {
                    fullPath,
                    name,
                    isFolder
                });
            }

            async checkDestination(destinationPath) {
                return await this.messageManager.sendCommand('checkDestination', {
                    destinationPath
                });
            }

            async move(sourcePath, targetPath, isFolder, overwrite = false) {
                return await this.messageManager.sendCommand('move', {
                    sourcePath,
                    targetPath,
                    isFolder,
                    overwrite
                });
            }

            async copy(sourcePath, targetPath, isFolder, overwrite = false) {
                return await this.messageManager.sendCommand('copy', {
                    sourcePath,
                    targetPath,
                    isFolder,
                    overwrite
                });
            }

            async ready() {
                return await this.messageManager.sendCommand('ready', {});
            }

            saveTreeState(expandedPaths) {
                this.messageManager.sendMessage('saveTreeState', { expandedPaths });
            }

            async executeMove(sourcePath, targetPath, isFolder, overwrite) {
                try {
                    await this.move(sourcePath, targetPath, isFolder, overwrite);
                    this.treeView.moveTreeNodeUI(sourcePath, targetPath);
                } catch (err) {
                    this.dialogManager.showErrorDialog(err);
                }
            }

            async executeCopy(sourcePath, targetPath, isFolder, overwrite) {
                try {
                    await this.copy(sourcePath, targetPath, isFolder, overwrite);
                    
                    const targetNode = this.treeView.nodeMap.get(targetPath);
                    if (targetNode) {
                        const name = sourcePath.split('/').pop();
                        const destinationPath = targetPath + '/' + name;

                        if (targetNode.isFolder) {
                            const li = targetNode.li;
                            const wasCollapsed = li.classList.contains('sne-collapsed');
                            
                            if (wasCollapsed) {
                                li.classList.remove('sne-collapsed');
                                this.treeView.addExpandedPath(targetPath);
                            }
                            
                            let ul = targetNode.getUl();
                            if (!ul || wasCollapsed) {
                                ul = targetNode.getOrCreateUl();
                                if (wasCollapsed) {
                                    const data = await this.expand(targetPath);
                                    ul.innerHTML = '';
                                    this.treeView.renderTree(data, targetPath);
                                } else {
                                    this.treeView.renderNode({
                                        name,
                                        fullPath: destinationPath,
                                        isFolder: isFolder,
                                    }, ul);
                                }
                            } else {
                                this.treeView.renderNode({
                                    name,
                                    fullPath: destinationPath,
                                    isFolder: isFolder,
                                }, ul);
                            }
                        }
                    }
                } catch (err) {
                    this.dialogManager.showErrorDialog(err);
                }
            }

            async removeNode(node) {
                try {
                    const data = await this.remove(node.fullPath, node.name, node.isFolder);
                    if (data.path && data.path !== '') {
                        if (node.isFolder) {
                            this.treeView.removeExpandedPath(node.fullPath);
                            for (const [path, nodeItem] of this.treeView.nodeMap.entries()) {
                                if (path.startsWith(node.fullPath + '/')) {
                                    this.treeView.nodeMap.delete(path);
                                    this.treeView.removeExpandedPath(path);
                                }
                            }
                        }
                        node.destroy();
                        this.treeView.nodeMap.delete(node.fullPath);
                    }
                } catch (err) {
                    if (err && err !== '') {
                        this.dialogManager.showErrorDialog(err);
                    }
                }
            }

            handlePasteCommand(command, sourcePath, isMovingFolder, dstPath, isDstFolder) {
                const targetPath = isDstFolder ? dstPath : dstPath.substring(0, dstPath.lastIndexOf('/'));

                if (isMovingFolder && targetPath.startsWith(sourcePath)) {
                    this.dialogManager.showErrorDialog(`Cannot ${command} a parent folder into its own subfolder.`);
                    return;
                }

                if (!isMovingFolder) {
                    const baseSource = sourcePath.substring(0, sourcePath.lastIndexOf('/'));
                    if (baseSource === targetPath) {
                        return;
                    }
                }

                if (sourcePath && targetPath && sourcePath !== targetPath) {
                    const sourceName = sourcePath.split('/').pop();
                    const targetName = targetPath.split('/').pop();
                    const destinationPath = targetPath + '/' + sourceName;
                    
                    // Check if destination already exists
                    this.checkDestination(destinationPath)
                        .then((result) => {
                            if (result.exists) {
                                // Destination exists
                                if (result.isFolder !== isMovingFolder) {
                                    // Different types - cannot overwrite
                                    const sourceType = isMovingFolder ? 'folder' : 'file';
                                    const destType = result.isFolder ? 'folder' : 'file';
                                    this.dialogManager.showErrorDialog(
                                        `Cannot overwrite ${destType} "${sourceName}" with ${sourceType}.`);
                                    return;
                                }
                                
                                // Same type - ask for override confirmation
                                const itemType = isMovingFolder ? 'folder' : 'file';
                                const action = command === 'copy' ? 'Copy' : 'Move';
                                const message = `"${sourceName}" ${itemType} already exists in "${targetName}". Overwrite?`;
                                
                                this.dialogManager.showConfirmDialog(
                                    message,
                                    () => {
                                        // User confirmed override
                                        this.executePasteCommand(command, sourcePath, isMovingFolder, targetPath, true);
                                    },
                                    () => {
                                        // User cancelled - do nothing
                                    }
                                );
                            } else {
                                // Destination doesn't exist - proceed with normal operation
                                const itemType = isMovingFolder ? 'folder' : 'file';
                                const action = command === 'copy' ? 'Copy' : 'Move';
                                const message = `${action} "${sourceName}" ${itemType} to "${targetName}" folder?`;
                                
                                this.dialogManager.showConfirmDialog(
                                    message,
                                    () => {
                                        // User confirmed
                                        this.executePasteCommand(command, sourcePath, isMovingFolder, targetPath, false);
                                    },
                                    () => {
                                        // User cancelled - do nothing
                                    }
                                );
                            }
                        })
                        .catch(err => {
                            this.dialogManager.showErrorDialog(err);
                        });
                }
            }

            executePasteCommand(command, sourcePath, isMovingFolder, targetPath, overwrite) {
                const tmp = sourcePath.split("/");
                const name = tmp[tmp.length - 1];
                const destinationPath = targetPath + "/" + name;

                // If overwriting, remove existing destination node from UI first
                if (overwrite) {
                    const existingDestNode = this.treeView.nodeMap.get(destinationPath);
                    if (existingDestNode) {
                        existingDestNode.destroy();
                        this.treeView.nodeMap.delete(destinationPath);
                        if (existingDestNode.isFolder) {
                            // Remove all children of the existing folder from nodeMap
                            for (const [path, nodeItem] of this.treeView.nodeMap.entries()) {
                                if (path.startsWith(destinationPath + '/')) {
                                    this.treeView.nodeMap.delete(path);
                                    this.treeView.removeExpandedPath(path);
                                }
                            }
                        }
                    }
                }

                if (command === 'move') {
                    this.executeMove(sourcePath, targetPath, isMovingFolder, overwrite);
                } else if (command === "copy") {
                    this.executeCopy(sourcePath, targetPath, isMovingFolder, overwrite);
                }
            }
        }

        // ============================================================================
        // DragAndDropHandler - Handles all drag-and-drop operations
        // ============================================================================
        class DragAndDropHandler {
            constructor(commandHandler, treeView) {
                this.commandHandler = commandHandler;
                this.treeView = treeView;
            }

            setupDragAndDrop(nodeItem, wrapper) {
                wrapper.ondragstart = (e) => {
                    if (nodeItem.isFolder && nodeItem.isTopLevel) {
                        e.preventDefault();
                        return;
                    }
                    e.dataTransfer.setData('text/plain', 
                        (nodeItem.isFolder ? "folder:" : "file:") + nodeItem.fullPath);
                };

                wrapper.ondragover = (e) => {
                    if (nodeItem.isFolder) {
                        e.preventDefault();
                        wrapper.style.backgroundColor = 'var(--vscode-list-hoverBackground)';
                    }
                };

                wrapper.ondragleave = () => {
                    if (nodeItem.isFolder) {
                        wrapper.style.backgroundColor = '';
                    }
                };

                wrapper.ondrop = (e) => {
                    e.preventDefault();
                    wrapper.style.backgroundColor = '';
                    this.handleDrop(e, nodeItem);
                };
            }

            async handleDrop(e, targetNodeItem) {
                const dragData = e.dataTransfer.getData('text/plain').split(":");
                const sourcePath = dragData[1];
                const isMovingFolder = dragData[0] === "folder";
                const targetPath = targetNodeItem.isFolder 
                    ? targetNodeItem.fullPath 
                    : targetNodeItem.fullPath.substring(0, targetNodeItem.fullPath.lastIndexOf('/'));

                // Delegate to command handler's handlePasteCommand with 'move' command
                this.commandHandler.handlePasteCommand('move', sourcePath, isMovingFolder, targetPath, targetNodeItem.isFolder);
            }
        }

        // ============================================================================
        // ContextMenuHandler - Handles all context menu actions
        // ============================================================================
        class ContextMenuHandler {
            constructor(commandHandler, treeView) {
                this.commandHandler = commandHandler;
                this.treeView = treeView;
                this.contextAction = '';
                this.contextActionTime = 0;
            }

            hideContextMenu() {
                this.treeView.contextMenu.style.display = 'none';
            }

            showContextMenu(x, y, node, li) {
                const menu = this.treeView.contextMenu;
                menu.innerHTML = '';

                if (node.isTopLevel) return;

                if (!node.isFolder) {
                    this.addMenuItem(menu, 'Open', () => {
                        this.commandHandler.messageManager.sendMessage('openFile', { path: node.fullPath });
                    });
                    this.addMenuItem(menu, 'Open as text', () => {
                        this.commandHandler.messageManager.sendMessage('openText', { path: node.fullPath });
                    });
                    this.addSeparator(menu);
                }

                this.addMenuItem(menu, 'Copy', () => {
                    this.contextAction = "copy:" + (node.isFolder ? "folder:" : "file:") + node.fullPath;
                    this.contextActionTime = Date.now();
                });

                this.addMenuItem(menu, 'Cut', () => {
                    this.contextActionTime = Date.now();
                    this.contextAction = "move:" + (node.isFolder ? "folder:" : "file:") + node.fullPath;
                });

                this.addMenuItem(menu, 'Paste', () => {
                    if (this.contextAction !== "") {
                        const tmp = this.contextAction.split(":");
                        if (tmp.length === 3) {
                            this.commandHandler.handlePasteCommand(
                                tmp[0], tmp[2], tmp[1] === "folder",
                                node.fullPath, node.isFolder);
                        }
                    }
                    this.contextAction = "";
                    this.contextActionTime = 0;
                }, (Date.now() - this.contextActionTime > 60000));

                this.addSeparator(menu);
                this.addMenuItem(menu, 'Open Config', () => {
                    this.commandHandler.messageManager.sendMessage('openConfig');
                });

                this.addSeparator(menu);
                this.addMenuItem(menu, 'Rename', () => {
                    const span = li.querySelector('.sne-editable');
                    span.contentEditable = true;
                    span.focus();
                });

                this.addMenuItem(menu, 'Delete', () => {
                    this.commandHandler.removeNode(node);
                });

                menu.style.left = `${x}px`;
                menu.style.top = `${y}px`;
                menu.style.display = 'block';
            }

            addMenuItem(menu, label, handler, disabled = false) {
                const div = document.createElement('div');
                div.textContent = label;
                if (disabled) {
                    div.classList.add('menu-item-disabled');
                }
                div.onclick = () => {
                    this.hideContextMenu();
                    if (!disabled) handler();
                };
                menu.appendChild(div);
            }

            addSeparator(menu) {
                const hr = document.createElement('hr');
                hr.className = 'sne-separator';
                menu.appendChild(hr);
            }
        }

        // ============================================================================
        // NodeItem - Handles UI rendering and delegates to handlers
        // ============================================================================
        class NodeItem {
            constructor(treeView, node, parentUl, isTopLevel) {
                this.treeView = treeView;
                this.name = node.name;
                this.fullPath = node.fullPath;
                this.isFolder = node.isFolder;
                this.isTopLevel = isTopLevel;
                this.init(parentUl);
            }

            init(parentUl) {
                const li = document.createElement('li');
                if (this.isFolder) {
                    li.classList.add('sne-collapsed');
                }

                const wrapper = document.createElement('div');
                wrapper.className = this.isFolder ? 'sne-folder' : 'sne-file';
                wrapper.draggable = !this.isTopLevel;

                const icon = document.createElement('span');
                icon.className = 'sne-icon';
                icon.innerHTML =
                    this.isFolder ?
                        '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#5f6368"><path d="M480-344 240-584l56-56 184 184 184-184 56 56-240 240Z"/></svg>'
                        : '<svg xmlns="http://www.w3.org/2000/svg" height="16px" viewBox="0 -960 960 960" width="16px" fill="#5f6368"><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-120H640q-30 38-71.5 59T480-240q-47 0-88.5-21T320-320H200v120Zm280-120q38 0 69-22t43-58h168v-360H200v360h168q12 36 43 58t69 22ZM200-200h560-560Zm80-270h400v-80H280v80Zm0-140h400v-80H280v80Z"/></svg>';

                const span = document.createElement('span');
                span.className = 'sne-editable';
                span.textContent = this.name;
                span.contentEditable = false;

                // Delegate to handlers
                this.treeView.dragAndDropHandler.setupDragAndDrop(this, wrapper);
                this.initItemRename(wrapper, span);
                this.initSingleClickHandlers(li, wrapper, span);

                wrapper.appendChild(icon);
                wrapper.appendChild(span);
                li.appendChild(wrapper);
                parentUl.appendChild(li);

                this.wrapper = wrapper;
                this.li = li;
                this.treeView.nodeMap.set(this.fullPath, this);
            }

            initItemRename(wrapper, span) {
                span.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        span.blur();
                    }

                    if (e.key === 'Esc' && span.contentEditable) {
                        e.preventDefault();
                        span.contentEditable = false;
                        span.textContent = this.name;
                    }
                };

                span.onblur = async () => {
                    if (!span.contentEditable) return;

                    let newName = span.textContent.trim();
                    span.contentEditable = false;

                    if (!this.isFolder && !newName.endsWith('.snippet')) {
                        newName = newName + '.snippet';
                    }

                    if (newName !== this.name) {
                        const parentPath = this.fullPath.substring(0, this.fullPath.lastIndexOf('/'));
                        const error = this.treeView._validateRename(parentPath, newName);

                        if (error) {
                            this.treeView.commandHandler.dialogManager.showErrorDialog(error);
                            span.textContent = this.name;
                            return;
                        }

                        try {
                            await this.treeView.commandHandler.rename(this.fullPath, newName);
                            const oldPath = this.fullPath;
                            this.name = newName;
                            this.fullPath = parentPath + '/' + newName;
                            span.textContent = newName;

                            this.treeView.nodeMap.set(this.fullPath, this);
                            this.treeView.nodeMap.delete(oldPath);

                            if (this.isFolder) {
                                this.treeView._updateSubtreePaths(oldPath, this.fullPath);
                            }
                        } catch (err) {
                            this.treeView.commandHandler.dialogManager.showErrorDialog(err);
                            span.textContent = this.name;
                        }
                    }
                };
            }

            initSingleClickHandlers(li, wrapper, span) {
                wrapper.oncontextmenu = (e) => {
                    e.preventDefault();
                    this.treeView.selectItem(this);
                    this.treeView.contextMenuHandler.showContextMenu(
                        e.clientX, e.clientY, this, li);
                };

                wrapper.onclick = (e) => {
                    this.treeView.selectItem(this);

                    if (this.isFolder) {
                        e.stopPropagation();
                        if (li.classList.contains('sne-collapsed')) {
                            li.classList.remove('sne-collapsed');
                            this.treeView.addExpandedPath(this.fullPath);
                            if (!li.querySelector('ul')) {
                                const ul = document.createElement('ul');
                                li.appendChild(ul);
                                this.treeView.commandHandler.expand(this.fullPath)
                                    .then((data) => {
                                        this.treeView.renderTree(data, this.fullPath);
                                    })
                                    .catch(err => {
                                        this.treeView.commandHandler.dialogManager.showErrorDialog(err);
                                    });
                            }
                        } else {
                            li.classList.add('sne-collapsed');
                            this.treeView.removeExpandedPath(this.fullPath);
                        }
                    }
                };

                span.ondblclick = () => {
                    this.treeView.selectItem(this);
                    if (!this.isFolder) {
                        this.treeView.contextMenuHandler.messageManager.sendMessage('openFile', {
                            path: this.fullPath
                        });
                    } else {
                        span.focus();
                    }
                };
            }

            toggleSelect(enable) {
                if (enable) {
                    this.wrapper.classList.add('sne-selected');
                } else {
                    this.wrapper.classList.remove('sne-selected');
                }
            }

            toggleExpand(expanded) {
                if (expanded) {
                    this.li.classList.remove('sne-collapsed');
                } else {
                    this.li.classList.add('sne-collapsed');
                }
            }

            getUl() {
                return this.li.querySelector('ul');
            }

            getOrCreateUl() {
                let ul = this.getUl();
                if (!ul) {
                    ul = document.createElement('ul');
                    this.li.appendChild(ul);
                }
                return ul;
            }

            destroy() {
                this.li.remove();
            }
        }

        // ============================================================================
        // SnippetTreeView - Main orchestrator (does NOT access MessageManager directly)
        // ============================================================================
        class SnippetTreeView {
            constructor(containerId, messageManager) {
                this.root = document.getElementById(containerId);
                this.contextMenu = document.getElementById('sne-context-menu');
                this.nodeMap = new Map();
                this.selectedNode = null;
                this.expandedPaths = new Set();

                // Store messageManager but don't use it directly
                this.messageManager = messageManager;

                // Initialize command handler first (it has dialogManager)
                this.commandHandler = new TreeCommandHandler(messageManager, this);
                
                // Initialize other handlers (they receive commandHandler)
                this.dragAndDropHandler = new DragAndDropHandler(this.commandHandler, this);
                this.contextMenuHandler = new ContextMenuHandler(this.commandHandler, this);

                // Register message handlers via MessageManager
                this.setupMessageHandlers();

                document.addEventListener('click', () => {
                    this.hideContextMenu();
                });

                this.init();
            }

            init() {
                window.addEventListener('scroll', () => {
                    this.hideContextMenu();
                }, true);

                window.addEventListener('click', () => {
                    this.hideContextMenu();
                }, true);
            }

            setupMessageHandlers() {
                // TreeView registers handlers but doesn't send messages directly
                this.messageManager.onMessage('addFolder', () => {
                    this.addFolder();
                });

                this.messageManager.onMessage('addSnippet', () => {
                    this.addSnippet();
                });

                this.messageManager.onMessage('refresh', (message) => {
                    this.reset();
                    this.renderTree(message.data.children);
                    if (message.data.treeState && message.data.treeState.length > 0) {
                        setTimeout(() => {
                            this.restoreTreeState(message.data.treeState);
                        }, 100);
                    }
                });

                this.messageManager.onMessage('addNode', (message) => {
                    const { name, fullPath, isFolder, parentPath } = message.data;
                    if (this.expandedPaths.has(parentPath)) {
                        const parentNode = this.nodeMap.get(parentPath);
                        if (parentNode && parentNode.isFolder) {
                            const ul = parentNode.getUl();
                            if (ul && !this.nodeMap.has(fullPath)) {
                                this.renderNode({
                                    name: name,
                                    fullPath: fullPath,
                                    isFolder: isFolder
                                }, ul, false);
                            }
                        }
                    }
                });
            }

            _validateRename(parentPath, newName) {
                if (!newName || newName.trim() === '') {
                    return 'Name cannot be empty';
                }

                if (newName.includes('/')) {
                    return "Name cannot contain '/'";
                }

                if (newName.includes('..')) {
                    return "Name cannot contain '..'";
                }

                const newFullPath = parentPath + '/' + newName;
                if (this.nodeMap.has(newFullPath)) {
                    return 'An item with this name already exists';
                }
                return null;
            }

            _updateSubtreePaths(oldBase, newBase) {
                for (const [path, nodeItem] of this.nodeMap.entries()) {
                    if (path.startsWith(oldBase + '/')) {
                        const newPath = newBase + path.substring(oldBase.length);
                        nodeItem.fullPath = newPath;
                        this.nodeMap.set(newPath, nodeItem);
                        this.nodeMap.delete(path);
                    }
                }

                const pathsToUpdate = Array.from(this.expandedPaths).filter(p => p.startsWith(oldBase + '/'));
                pathsToUpdate.forEach(oldPath => {
                    this.expandedPaths.delete(oldPath);
                    const newPath = newBase + oldPath.substring(oldBase.length);
                    this.expandedPaths.add(newPath);
                });
            }

            addExpandedPath(path) {
                this.expandedPaths.add(path);
                this.saveTreeState();
            }

            removeExpandedPath(path) {
                this.expandedPaths.delete(path);
                this.saveTreeState();
            }

            saveTreeState() {
                this.commandHandler.saveTreeState(Array.from(this.expandedPaths));
            }

            restoreTreeState(expandedPaths) {
                if (!expandedPaths || expandedPaths.length === 0) {
                    return;
                }

                this.expandedPaths = new Set(expandedPaths);
                const pathsToRestore = expandedPaths.filter(folderPath => {
                    const nodeItem = this.nodeMap.get(folderPath);
                    return nodeItem && nodeItem.isFolder;
                });

                pathsToRestore.forEach(folderPath => {
                    const nodeItem = this.nodeMap.get(folderPath);
                    if (nodeItem && nodeItem.isFolder) {
                        const li = nodeItem.li;
                        if (li.classList.contains('sne-collapsed')) {
                            li.classList.remove('sne-collapsed');
                            if (!li.querySelector('ul')) {
                                const ul = document.createElement('ul');
                                li.appendChild(ul);
                                this.commandHandler.expand(folderPath)
                                    .then((data) => {
                                        this.renderTree(data, folderPath);
                                    })
                                    .catch(err => {
                                        this.commandHandler.dialogManager.showErrorDialog(err);
                                    });
                            }
                        }
                    }
                });
            }

            addFolder() {
                this._expandAndAddNode(true);
            }

            addSnippet() {
                this._expandAndAddNode(false);
            }

            _expandAndAddNode(isFolder) {
                const selected = this.selectedNode;
                if (!selected) {
                    this.commandHandler.dialogManager.showErrorDialog("Please select a folder first.");
                    return;
                }

                const selectedPath = selected.fullPath;
                const parentPath = selected.isFolder ? selectedPath : selectedPath.substring(0, selectedPath.lastIndexOf('/'));

                const parentLiEl = this.nodeMap.get(parentPath);
                if (!parentLiEl) {
                    this.commandHandler.dialogManager.showErrorDialog("Parent folder not found. Please select a folder first.");
                    return;
                }

                const subtreeLoaded = parentLiEl.getUl();

                if (!subtreeLoaded) {
                    const wrapper = parentLiEl.wrapper;
                    if (wrapper && parentLiEl.li.classList.contains('sne-collapsed')) {
                        wrapper.dispatchEvent(new MouseEvent('click', { bubbles: true }));
                    }
                    setTimeout(() => this._addEmptyEditableNode(parentPath, isFolder), 200);
                    return;
                }

                if (parentLiEl.li.classList.contains('sne-collapsed')) {
                    parentLiEl.li.classList.remove('sne-collapsed');
                    this.addExpandedPath(parentPath);
                }

                setTimeout(() => this._addEmptyEditableNode(parentPath, isFolder), 100);

            }


            _addEmptyEditableNode(parentPath, isFolder) {
                const parentNode = this.nodeMap.get(parentPath);
                if (!parentNode) {
                    this.commandHandler.dialogManager.showErrorDialog("Parent folder not found. Please try again.");
                    return;
                }

                const ul = parentNode.getOrCreateUl();

                if (ul.querySelector('.sne-editing')) {
                    ul.querySelector('.sne-editing').remove();
                }

                const tempFullPath = parentPath + '/';
                const node = {
                    name: '',
                    fullPath: tempFullPath,
                    isFolder: isFolder
                };

                const li = document.createElement('li');
                const wrapper = document.createElement('div');
                wrapper.className = (isFolder ? 'sne-folder' : 'sne-file') + ' sne-editing';

                const icon = document.createElement('span');
                icon.className = 'sne-icon';
                icon.innerHTML = isFolder ? '> ' : '= ';

                const span = document.createElement('span');
                span.className = 'sne-editable';
                span.contentEditable = true;
                span.textContent = '';
                span.dataset.fullPath = tempFullPath;
                span.dataset.isFolder = String(isFolder);

                const error = document.createElement('div');
                error.style.color = 'var(--vscode-errorForeground)';
                error.style.fontSize = '11px';
                error.style.padding = '0 2px';

                function cleanup() {
                    li.remove();
                }

                let self = this;
                function handleValidate() {
                    const newName = span.textContent.trim();

                    let errorName = self._validateRename(parentPath, newName);

                    if (errorName) {
                        error.textContent = errorName;
                        return false;
                    }

                    // clear error if new name is valid
                    error.textContent = '';
                    return true;
                }

                async function handleCreate() {
                    let newName = span.textContent.trim();
                    
                    
                    if (!handleValidate()) {
                        if (newName === '') cleanup();
                        return;
                    }

                    if (!span.contentEditable) {
                        return;
                    }

                    if (!isFolder && !newName.endsWith('.snippet')) {
                        newName = newName + '.snippet';
                        span.textContent = newName;
                    }
        
                    // update span text content to the new name
                    span.textContent = newName;
                    // disable content editable
                    span.contentEditable = false;

                    const newFullPath = parentPath + '/' + newName;

                    try {
                        if (isFolder) {
                            await self.commandHandler.createFolder(newFullPath);
                        } else {
                            await self.commandHandler.createSnippet(newFullPath);
                        }

                        cleanup();
                        
                        const parentNode = self.nodeMap.get(parentPath);
                        if (parentNode && parentNode.isFolder) {
                            parentNode.li.classList.remove('sne-collapsed');
                            self.addExpandedPath(parentPath);
                        }
                        
                        self.renderNode({
                            name: newName,
                            fullPath: newFullPath,
                            isFolder: isFolder
                        }, ul, false);

                    } catch (err) {
                        cleanup();
                        self.showErrorDialog(err.message || "Failed to create item.");
                    }
                }

                span.oninput = () => {
                    handleValidate();
                };

                span.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        span.blur();
                    } else {
                        handleValidate();
                    }
                };

                span.onblur = () => {
                    handleCreate();
                };

                wrapper.appendChild(icon);
                wrapper.appendChild(span);
                li.appendChild(wrapper);
                li.appendChild(error);
                ul.appendChild(li);
                span.focus();
            }


            hideContextMenu() {
                this.contextMenuHandler.hideContextMenu();
            }

            showContextMenu(x, y, node, li) {
                // Delegate to context menu handler
                this.contextMenuHandler.showContextMenu(x, y, node, li);
            }

            selectItem(nodeItem) {
                if (this.selectedNode) {
                    this.selectedNode.toggleSelect(false);
                }
                nodeItem.toggleSelect(true);
                this.selectedNode = nodeItem;
            }

            moveTreeNodeUI(sourcePath, targetPath) {
                const sourceNode = this.nodeMap.get(sourcePath);
                if (!sourceNode) {
                    return;
                }

                const baseName = sourceNode.name;
                const isFolder = sourceNode.isFolder;
                const destinationPath = `${targetPath}/${baseName}`;

                // Check if destination already exists in UI (for overwrite case)
                const existingDestNode = this.nodeMap.get(destinationPath);
                if (existingDestNode) {
                    // Remove existing destination node
                    existingDestNode.destroy();
                    this.nodeMap.delete(destinationPath);
                    if (existingDestNode.isFolder) {
                        // Remove all children of the existing folder from nodeMap
                        for (const [path, nodeItem] of this.nodeMap.entries()) {
                            if (path.startsWith(destinationPath + '/')) {
                                this.nodeMap.delete(path);
                                this.removeExpandedPath(path);
                            }
                        }
                    }
                }

                sourceNode.destroy();
                this.nodeMap.delete(sourcePath);

                const targetNode = this.nodeMap.get(targetPath);
                if (!targetNode) {
                    // Target node not found, request refresh from backend
                    this.commandHandler.dialogManager.showErrorDialog('Target folder not found. Please refresh the tree.');
                    this.commandHandler.ready()
                        .then((data) => {
                            this.reset();
                            this.renderTree(data.children || data);
                            if (data.treeState && data.treeState.length > 0) {
                                setTimeout(() => {
                                    this.restoreTreeState(data.treeState);
                                }, 100);
                            }
                        })
                        .catch(err => {
                            this.commandHandler.dialogManager.showErrorDialog(err);
                        });
                    return;
                }

                // Ensure target folder is expanded
                if (targetNode.isFolder) {
                    const li = targetNode.li;
                    const wasCollapsed = li.classList.contains('sne-collapsed');
                    
                    if (wasCollapsed) {
                        li.classList.remove('sne-collapsed');
                        this.addExpandedPath(targetPath);
                    }

                    // Get or create the UL for the target folder
                    let ul = targetNode.getUl();
                    
                    if (!ul || wasCollapsed) {
                        // If UL doesn't exist or folder was collapsed, create it and load children
                        ul = targetNode.getOrCreateUl();
                        // Load children from backend (which includes the moved item)
                        this.commandHandler.expand(targetPath)
                            .then((data) => {
                                // Clear existing children in UL to avoid duplicates
                                ul.innerHTML = '';
                                // Render all children (including the moved item)
                                this.renderTree(data, targetPath);
                            })
                            .catch(err => {
                                this.commandHandler.dialogManager.showErrorDialog(err);
                            });
                    } else {
                        // Folder is already expanded, just render the moved node
                        const newNode = {
                            name: baseName,
                            fullPath: destinationPath,
                            isFolder: isFolder
                        };
                        this.renderNode(newNode, ul, false);
                    }
                } else {
                    // Target is a file (shouldn't happen, but handle it)
                    const parentPath = targetPath.substring(0, targetPath.lastIndexOf('/'));
                    const parentNode = this.nodeMap.get(parentPath);
                    if (parentNode) {
                        const ul = parentNode.getOrCreateUl();
                        const newNode = {
                            name: baseName,
                            fullPath: destinationPath,
                            isFolder: isFolder
                        };
                        this.renderNode(newNode, ul, false);
                    }
                }
            }

            findInsertionPosition(node, parentUl, excludeLi = null) {
                // Get all existing children as an array, excluding the node we're inserting
                const children = Array.from(parentUl.children).filter(li => li !== excludeLi);
                
                // Find the position where this node should be inserted
                // Sort order: folders first, then files, both alphabetically
                for (let i = 0; i < children.length; i++) {
                    const childLi = children[i];
                    const childWrapper = childLi.querySelector('.sne-folder, .sne-file');
                    if (!childWrapper) continue;
                    
                    const childName = childWrapper.querySelector('.sne-editable')?.textContent || '';
                    const childIsFolder = childWrapper.classList.contains('sne-folder');
                    
                    // Compare: folders come before files
                    if (node.isFolder && !childIsFolder) {
                        return childLi; // Insert before this file
                    }
                    if (!node.isFolder && childIsFolder) {
                        continue; // Skip folders, we're a file
                    }
                    
                    // Same type, compare alphabetically
                    if (node.name.localeCompare(childName) < 0) {
                        return childLi; // Insert before this node
                    }
                }
                
                // Insert at the end (null means append)
                return null;
            }

            renderNode(node, parentUl, isTopLevel = false) {
                // Create the node item (it will append itself to parentUl)
                const item = new NodeItem(this, node, parentUl, isTopLevel);
                this.nodeMap.set(node.fullPath, item);
                
                // Find the correct insertion position (excluding the node we just created)
                const insertBefore = this.findInsertionPosition(node, parentUl, item.li);
                
                // If we need to move it, remove and re-insert at correct position
                if (insertBefore !== null) {
                    parentUl.removeChild(item.li);
                    parentUl.insertBefore(item.li, insertBefore);
                }
                // If insertBefore is null, the node is already at the end (correct position)
            }

            renderTree(data, parentPath = null) {
                const parentNode = parentPath ? this.nodeMap.get(parentPath) : null;
                const ul = parentNode?.getOrCreateUl() || this.root;
                data.forEach(node => this.renderNode(node, ul, parentPath === null));
            }

            reset() {
                this.root.innerHTML = '';
                this.nodeMap.clear();
            }
        }

        // ============================================================================
        // Initialization
        // ============================================================================
        // Initialize MessageManager first
        const messageManager = new MessageManager();
        messageManager.initialize();

        // Create TreeView with MessageManager (but TreeView doesn't use it directly)
        const tree = new SnippetTreeView('sne-tree', messageManager);

        // Initial load uses commandHandler, not MessageManager directly
        tree.commandHandler.ready()
            .then((data) => {
                tree.reset();
                tree.renderTree(data.children || data);
                if (data.treeState && data.treeState.length > 0) {
                    setTimeout(() => {
                        tree.restoreTreeState(data.treeState);
                    }, 100);
                }
            })
            .catch(err => {
                tree.commandHandler.dialogManager.showErrorDialog(err);
            });


    </script>
</body>

</html>